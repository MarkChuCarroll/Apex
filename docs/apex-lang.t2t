Apex Skimmer Language Reference
by Mark C. Chu-Carroll (markcc@gmail.com/mchucarroll@google.com)
Last updated: %%mtime(%A %B %d, %Y)

%!target: html

= Basics =

== Ranges ==

All command operate on //ranges//. A range is a sequence of consecutive characters. A buffer is a special case of a range - it's a range that's also associated with a file. Most other ranges will be pieces of a buffer.

The way that commands work is by //skimming// the buffer. That is, the most basic operation in Skimmer is searching for a region of the current range, and then performing some action there. While a given range is the focus of execution, it contains a //cursor// which selects a range within the currently active range.

The canonical skimmer operation is slice-and-splice. A slice-and-splice includes an expression that describes a range of text in an input range. The input range is then sliced into a collection of sub-ranges, called //slices// - one for each match of the expression. Then some edit command is executed on each of the slices, and the result is //spliced// back in to the original buffer.

== Skimming ==

There's always a //current range// which is the target of any program statement. Skimming is a way of sliding a cursor around the range. For example, a program like  ``2ml 3m s/foo/`` means "from the cursor point in the current range, move forward two lines, then forward three characters, and then move the cursor to the start of the first match of regular expression 'foo'".

== Success and Failures ==

In Skimmer programs, all conditions are driven by the idea of
success and failure. //Any// program statement or expression can be
used as the condition of a control structure. If the command completes
successfully, then it's treated as true.

This has a variety of very interesting impacts on the language. For
example, there is no need for a conditional statement. Any two
statements connected in sequence are, effectively a conditional. If
the first statement fails, then the sequence fails - so ``X Y`` is
effectively "if X then Y". If/then/else is done using alternation:
``X|Y`` basically does ``X``; if ``X`` fails, then it does ``Y``.


= Syntax =

Commands come before explicit parameters. In addition to specified parameters, there' always a cursor which is passed explicitly.

== Motion Commands ==

  - Move cursor a specific distance: ``m``, for move.  ``b`` is an
    alias for backward. ``b`` is equivalent to ``m-3``.
    Each move specifies a unit with the numeric argument: ``c`` for
    character, ``l`` for line, and ``p`` for page. ``f3l`` moves the
    cursor forward by three lines.
  - Move the cursor to a specific location: ``j`` for jump. Takes
    parameters just like ``f``.
  - Move to pattern: ``s/pattern/``. The match will become the new 
    cursor.
  - Extend cursor: ``e``, followed by either ``<`` or ``>`` as
    an indicator for beginning or end of the cursor followed by
    a move command.  Moves either the  beginning or end of the
    current cursor, altering the current range.  
    As a special case, if you ``ew`` or ``el`` without specifying an
    anchor or a distance, it will extend the selection to the current
    word/line. For example, you could select a word around "set" 
    using ``s/set/ ew``.

== Actions ==

=== Variables and Expressions ===


- ``$ident`` - a variable is a string of letters, digits, and underscores preceeded by a dollar sign.
- assignments: there are several forms of assignment:
   - ``!($var, expr)``: assign a variable to a value.
   - ``!$var``: assign the contents of the current range to
     a variable.
   - ``!<$var``: assign the position of the beginning of the range
     to the variable.
   - ``!>$var``: assign the position of the end of the range to the 
     variable.
- Expressions are written inside of square brackets: 
   - ``+``, ```-```, ``*``, ``/``, and ``%`` are all integer 
     arithmetic in expressions. ``[3 + 5]`` evaluates to 8.
   - ``.`` is string concatenation. ``[3 . 5]`` evaluates to ``35``.
   - ``<``, ``>``, ``<=``, ``>=``, and ``!`` are string comparison,
    which succeed  if true, and fail if false.
   - ``&`` is logical and, which suceeds if both sides succeed.
   - ``^`` is logical or, which succeeds if either alternative
     succeeds.
   - ``#<``, ..., are numeric comparison.

=== Edits === 

  - Delete: ``d``. Takes parameter just like ``f``. ``d3l`` deletes
    three lines. 

  - insert: ``i/stuff/``.

  - slice&splice ``slice_expr { code }``.


=== Selection ===

  - Kill selection: ``d``. 
  - execute program on selection (push and run)	``sel_expr x { code }``. fThis
    is, effectively, just using a combination of success/fail and the
    implicit selection/cursor. The selection expression either succeeds or
    fails. If it fails, the entire expression containing it fails, so
    the x command doesn't run. But if it succeeds, then x gets run, which
    executes the code block.
	
=== Iteration ===

- ``a(/pattern/,action)``: all; this is the canonical slice-and-splice. It finds all of the matches for the pattern,
and then iterates through them, executing the action on all 
of them.
- ``r(count,action)``: repeat action count times. Count is either
  a number, a variable (which must contain a number), or an
  expression.
- ``x(action)``: executes the action repeatedly, as long as
  it succeeds.
- ``command & command``: perform the first command,
  and if it succeeds, perform the second.
- ``command ^ command``: perform the first command, and if it fails,
  perform the second.
- 
  

=== I/O ===


- read new file: ``BR'filename'``: buffer read filename.
- save buffer ``BW'filename'``: buffer write. If no "filename" is present,
    then write to the same file that the buffer was read from.


== Examples ==


- Replace all tabs with spaces:  
    ``a/^i/  x{ !($count, [8 - ($_col % 8)]) & r($count)x {i/ /} }``
   - match ``^i`` (tab)
   - for all matches, execute the block. (ax - all-matches-execute)
   - take the column, mod-8, and subtract that from 8. That gives
     you the number of spaces to the next tab stop.
   - Using that as a numeric parameter, execute the inner block
     that number of times. (rx - repeated execute, repeats it numeric-param
     number times)

- Can clean that up:
  ``sub nearest_tab { 8 - ($_col % 8) }``
  ``a/^i/ { r(nearest_tab())x {i/ /}}``



- ``sub f {| $x |   (($x, 0)= 1) | *(f(x-1), x)}``
  - declare ``f`` as a subroutine.
  - Code block is the body of the subroutine.
  - subroutines either succeed or fail, and return a value.
  - ``=($x,0)`` is a comparison function; it succeeds if its parameters are equal.
  - ``=($x, 0) 1`` runs "1" if ``($x, 0)=`` succeeds. ``1`` just returns
    the value 1. So it is, effectively, "if $x = 0 then return 1".
  - ``|`` is alternative; if its left fails, then its right is evaluated. 
  - So... this is a factorial function. If comparing ``$x`` to 0, we return
    1. Otherwise, we evaluate ``*(f(-($x,1)),$x)`` - that is, ``-($x,1)``
    which evaluates x-1; ``f``, which evaluates the subroutine ``f`` (it's
    a recursive call) on x-1, and then multiplies it by x. 

stmts : motion_stmt
	  ;

motion_stmt : distance motion_command ;

distance:
	( number p)? (number l)? (number c)?
  ;

// So, move(3p-4l10c) means "move forward 3 pages, back 4 lines, and forward 
// 10 characters".

[pos_expr, pos_expr] defines a new range.

[pos,pos]exec{ block } - runs block with the range as its focus.

motion_command:
    'm' // move
  | 'j' // jump
  ;


expr :
    number
  | variable
  | call
  | block
  | regex
  ;

call: ( expr )? function_ident
    ;

block :  "{"  ('|' ( ident )+ '|' )?  stmts "}"
      ;


move(1c);
jump(10l);





