Apex Skimmer Language Reference
by Mark C. Chu-Carroll (markcc@gmail.com/mchucarroll@google.com)
Last updated: %%mtime(%A %B %d, %Y)

%!target: html

= Basics =

== Ranges ==

All command operate on //ranges//. A range is a sequence of consecutive
characters. A buffer is a special case of a range - it's a range that's also
associated with a file. Most other ranges will be pieces of a buffer.

The way that commands work is by //skimming// the buffer. That is, the most
basic operation in Skimmer is searching for a region of the current
range, and then performing some action there.

The canonical skimmer operation is slice-and-splice. A slice-and-splice
includes an expression that describes a range of text in an input range. The
input range is then sliced into a collection of sub-ranges, called
//slices// - one for each match of the expression. Then some edit command
is executed on each of the slices, and the result is //spliced// back in
to the original buffer.

== Skimming ==

As I said above, skimming is a basic concept. There's always a //current
range// which is the target of any program statement. Skimming is a way of
sliding a cursor around the range. For example, a program like 
``2ml 3m s/foo/`` means "from the cursor point in the current range, move forward two lines, then forward three characters, and thes move the cursor to the start of the first match of regex 'foo'".


== Success and Failures ==


In Skimmer programs, all conditions are driven by the idea of 
success and failure. //Any// program statement or expression can be
used as the condition of a control structure. If the command completes
successfully, then it's treated as true.

This has a variety of very interesting impacts on the language. For
example, there is no need for a conditional statement. Any two
statements connected in sequence are, effectively a conditional. If
the first statement fails, then the sequence fails - so ``X Y`` is
effectively "if X then Y". If/then/else is done using alternation: 
``X|Y`` basically does ``X``; if ``X`` fails, then it does ``Y``.


= Syntax =


Most numeric parameters are passed in postfix syntax. So to move
three lines, you put the parameter "3" first: "3m". Most string
parameters are passed postfix.

Multiple parameters are wrapped in parens; single parameters can be
done without parens.





== Motion Commands ==


  - Move cursor a specific distance: ``m``, for move.  ``b`` is an
    alias for backward. ``3b`` is equivalent to ``-3m``.
    Optionally specifies a unit with the numeric argument: ``c`` for
    character, ``l`` for line, and ``p`` for page. ``3lf`` moves the
    cursor forward by three lines.
  - Move the cursor to a specific location: ``j`` for jump. Takes
    parameters just like ``f``.
  - Move to pattern: ``s/pattern/``.


== Selection Commands ==


  - find and select matching pattern: ``s/pattern/``
  - expand selection to words: ``ew``
  - expand selection to lines: ``el``

For example, you could select a word around "set" using ``s/set/ ew``.


== Actions ==


=== Variables and Expressions===


- ``$ident`` - a variable is a string of letters, digits, and underscores
   preceeded by a dillar sign.
- assignments: ``$ident : expr``
- Arithmetic works roughly as usual: ``*``(mult), ``/`` (divide),
  ``+`` (add), ``-`` (subtract).
- $f(params) is function application.


=== Edits ===


  - Delete: ``d``. Takes parameter just like ``f``. ``3ld`` deletes
    three lines.

  - insert: ``i/stuff/``.

  - slice&splice ``slice_expr { code }``.


=== Selection ===


  - Copy selection: ``c``
  - Kill selection: ``k``.
  - execute program on selection (push and run)	``sel_expr x { code }``.


=== I/O ===


- read new file: ``BR'filename'``: buffer read filename.
- save buffer ``BW'filename'``: buffer write. If no "filename" is present,
    then write to the same file that the buffer was read from.


== Examples ==


- Replace all tabs with spaces:  ``a/^i/  x{ (8 - ($_col % 8)) rx {i/ /} }``
   - match ``^i`` (tab)
   - for all matches, execute the block. (ax - all-matches-execute)
   - take the column, mod-8, and subtract that from 8. That gives
     you the number of spaces to the next tab stop.
   - Using that as a numeric parameter, execute the inner block
     that number of times. (rx - repeated execute, repeats it numeric-param
     number times)

- Can clean that up:
  ``sub nearest_tab { 8 - ($_col % 8) }``
  ``a/^i/ { nearest_tab() rx {i/ /}}``
- ``sub f {| $x |   ($x, 0)= ? 1 : ((x-1)f * x)}``
  - declare ``f`` as a subroutine.
  - Code block is the body of the subroutine.
  - subroutines either succeed or fail, and return a value.
  - ``($x,0)=`` is a comparison function; it succeeds if its parameters are equal.
  - ``($x, 0)= 1`` runs "1" if ``($x, 0)=`` succeeds. ``1`` just returns
    the value 1. So it is, effectively, "if $x = 0 then return 1".
  - ``|`` is alternative; if its left fails, then its right is evaluated. 
  - So... this is a factorial function. If comparing ``$x`` to 0, we return
    1. Otherwise, we evaluate ``(($x,1)-f,$x)*`` - that is, ``($x,1)-``
    which evaluates x-1; ``f``, which evaluates the subroutine ``f`` (it's
    a recursive call) on x-1, and then multiplies it by x. 

stmts : motion_stmt
	  ;

motion_stmt : distance motion_command ;

distance:
	( number p)? (number l)? (number c)?
  ;

// So, move(3p-4l10c) means "move forward 3 pages, back 4 lines, and forward 
// 10 characters".

[pos_expr, pos_expr] defines a new range.

[pos,pos]exec{ block } - runs block with the range as its focus.

motion_command:
    'm' // move
  | 'j' // jump
  ;


expr :
    number
  | variable
  | call
  | block
  | regex
  ;

call: ( expr )? function_ident
    ;

block :  "{"  ('|' ( ident )+ '|' )?  stmts "}"
      ;


move(1c);
jump(10l);





